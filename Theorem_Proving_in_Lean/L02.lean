import Mathlib
import Counterexamples.Girard

/-
# (Lean 中的) 类型论基础

Lean 是基于 **依赖类型论** 工作的定理证明器, 这也是其正确性的保证. 类型论可以看作是集合论的延申, 它用一套不同的框架建立了逻辑体系. 类型论分为很多种, 每种类型论在其基本公理假设和语言语法上有所区别, Lean 中使用的是依赖类型论. 以下我们把 Lean 中使用的依赖类型论简称为类型论.

我们先来介绍一些类型论中的基本概念. 在类型论中, 最基本的表达式形如 `x : t`. 我们把这个表达式中冒号前面的部分, 在这里就是 `x`, 称为 **元素 (Eng. term)**, 把冒号后面的部分, 在这里就是 `t`, 称为 **类型 (Eng. type)**. 因此, 我们可以说这个表达式表示, "元素 `x` 的类型是 `t`", 或者说 "`x` 是类型 `t` 中的一个元素".

实际上, 我们上节课中介绍的 `(a b c : ℝ)` 这种写法也表达同样的含义. 这里的 `ℝ` 被称为实数类型, `a b c` 则是实数类型中的三个元素. 对于元素与类型之间的关系, 我们可以用集合论中元素与集合之间的关系来进行类比理解, 即我们可以把 `a b c` 当成是来自实数集的三个元素, 那这时候 `a : ℝ` 这个表达式就可以被理解为是 `a ∈ ℝ` 这样一个命题.

但这样的类比并不准确, 我们通过一个例子来感受二者之间的区别. 在集合论中, 元素对集合的属于关系实际上是一个命题, 因此我们可以谈论如 `0.5 ∈ ℕ` 这样的命题. 我们知道, 这当然是一个假命题, 但这个假命题本身是有意义的, 它表示 "0.5 属于自然数集" 这个陈述, 尽管这是不对的. 可是在类型论中, `0.5 : ℕ` 这个表达式并非是一个命题, 这样的写法是不被允许的, 没有任何意义, 因为 0.5 的类型不是也不可能是自然数类型. 这无关对错, 而是我们根本就无法谈论这一点. 因此, 在类型论中, 类型更像是元素的固有属性, 而非像集合论中的集合那样, 充当容器的作用.

对于 `x : t` 这样一个表达式, 表达式整体的值实际上是 `x`, `: t` 这一部分更多地起到一个标注的作用, 即显式地写出了元素 `x` 的类型. 这样的写法是有一定好处的, 我们可以通过下面的例子来看到这一点. 在展示例子之前, 我们要对上节课讲的内容做一点修正和完善. 实际上, 上节课介绍的 `#check` 命令是用来检查一个表达式的类型的, 也就是说 `#check x` 这个命令会在信息窗口中展示出元素 `x` 的类型.
-/

/-
0 : ℕ
-/
#check 0

/-
1 : ℕ
-/
#check 1

/-
1 : ℝ
-/
#check (1 : ℝ)

/-
Real.pi : ℝ
-/
#check Real.pi

/-
Complex.I : ℂ
-/
#check Complex.I

/-
在上面的例子中我们看到, 当我们写下一个自然数的时候, Lean 会默认这个数的类型是自然数类型 `ℕ`. 如果我们想要把这个自然数当成一个实数类型的元素来使用, 我们需要对它的类型进行显式标注, 也就是使用 `1 : ℝ` 的形式. 这时候整个表达式所表示的值还是 `1`, 但这个 `1` 的类型已经是实数类型 `ℝ` 了, 因此 `#check` 后的结果显示 `1` 的类型是 `ℝ`. 最后两个展示的例子中分别提到了 `Real.pi` 和 `Complex.I`, 其中的 `Real` 和 `Complex` 就是我们上节课讲过的命名空间, 分别代表实数相关内容和复数相关内容, `pi` 和 `I` 分别是其中的定义, 表示圆周率和虚数单位.
-/

/-
## 类型宇宙 `Type`

在类型论中, 一个重要的原则是 **类型论中的一切对象都有类型**! 因此自然数类型 `ℕ`, 实数类型 `ℝ` 这些类型也应当有类型. 那么它们的类型是什么呢? -- 我们可以通过 `#check` 命令来查看这一点.
-/

/-
ℕ : Type
-/
#check ℕ

/-
ℝ : Type
-/
#check ℝ

/-
从 `#check` 命令的结果我们可以看出, 自然数类型 `ℕ` 和实数类型 `ℝ` 的类型都是 `Type` -- 它是大部分我们所关心的类型的类型. 实际上, 如果我们仍然不严谨地将之与集合论类比来看的话, 这会更加容易理解: `Type` 是一个装着所有类型的集合, 那么 `ℕ` 和 `ℝ` 自然是其中的元素.

回顾我们刚刚提到的原则, 既然类型论中的一切对象都有类型, 那么 `Type` 也应该有类型, 它的类型又是什么? `Type` 既然是类型的类型, 那么它的类型会是它自己吗? 我们仍然使用 `#check` 命令来查看这一点.
-/

/-
Type : Type 1
-/
#check Type

/-
结果与我们预期的并不相同, `Type` 的类型不再是它自己, 而是 `Type 1`. 实际上, 如果 `Type` 的类型是它自己的话, 将会导致 Girard 悖论. 如果我们再次以集合论类比, 这实际上类似于罗素悖论. Lean 中也有关于 Girard 悖论的证明, 我们放在附录中以供感兴趣的同学参考¹.

正是由于这种 "自己不能成为自己的类型" 的约束, 我们可以自然地在类型论中建立 **宇宙 （Eng. universe)** 的概念. 我们将 `Type` 类型称为一个宇宙, 那么其元素如 `ℕ`, `ℝ` 等类型就都属于 `Type` 宇宙. 一个宇宙的类型会成为比其高一阶的宇宙, 因此 `Type 1` 也是一个宇宙, 它比 `Type` 要高一阶. 不难猜测, `Type 1` 的类型应该是 `Type 2`, 是比 `Type 1` 高一阶的宇宙. 一般地, 宇宙 `Type u` 的类型是 `Type (u + 1)`.
-/

/-
Type 1 : Type 2
-/
#check Type 1

/-
Type 2 : Type 3
-/
#check Type 2

universe u  -- 声明一个宇宙 `u`

/-
Type u : Type (u + 1)
-/
#check Type u

/-
## 命题宇宙 `Prop`

对于定理证明来说, 我们往往更关注 `Type` 宇宙而非更高阶的宇宙, 因此大多数我们熟知的数学对象也都来自于这个宇宙, 比如之前已经见到的 `ℕ`, `ℝ`, `ℂ` 等.

除此之外, `Type` 宇宙中还有着一个特殊的元素, 它叫做 `Prop`, 是单词 proposition 的缩写. 由于本身是 `Type` 类型的元素, `Prop` 应当也是一个类型. 从名字上可以看出, 这个类型中的元素实际上就是一个个数学命题. 我们也可以通过以下例子更直观地看到这一点:
-/

#check Prop

/-
1 + 1 = 2 : Prop
-/
#check 1 + 1 = 2
#eval 1 + 1 = 2
#check (1 + 1 = 2 : Bool)
#check (true : Prop)

/-
∃ n, 1 < n : Prop
-/
#check ∃ (n : ℕ), 1 < n

/-
∀ n ≥ 3, ∃ x y z, x ^ n + y ^ n = z ^ n : Prop
-/
#check ∀ n ≥ 3, ∃ (x y z : ℤ), x ^ n + y ^ n = z ^ n


#check And
#print And

/-
上面的例子展示了三个数学命题, 我们可以看到, `Prop` 中的元素不仅可以是真命题, 还可以是假命题.

同时我们也注意到, 信息窗口中展示的信息和我们使用 `#check` 命令检查的元素有所不同. 实际上信息窗口中信息以何种方式展示也是人为规定好的, 因此这些信息只会机械地遵守规定, 有时就会与我们提供的元素有所不同. 至于这些命题的写法, 我们后面再谈.

`Type` 宇宙中的元素是一个个类型, 而这些类型本身又可以有一些元素, 比如 `0 : ℕ`, `1 : ℝ` 等等, 但是这些类型中的元素 `0`, `1` 不会再成为类型. 从模式上来讲, 命题类型 `Prop` 理应如此. 因为它本身是 `Type` 类型的元素, 因此一个命题 `p : Prop` 不应当再是一个类型. 可实际上, Lean 中允许一个命题再次成为一个类型, 即上述的 `1 + 1 = 2`, `∃ (n : ℕ), 1 < n` 等都是类型, 它们的元素这时候也称为是它们的 **证明**. 这里的 "证明" 不仅仅是一个名字, 它们也真的起到了数学上所谓的证明的含义. 也就是说, 如果我们可以找到命题 `p : Prop` 的一个证明, 那么 `p` 就是一个真命题; 而如果我们无法找到命题 `p : Prop` 的一个证明, 那么 `p` 就是一个假命题.

以上观点叫做 "Curry-Howard correspondence", 它成为了数学证明和计算机程序之间的纽带, 成功地将定理的证明和类型、元素联系起来, **证明一个定理实际上就是去构造一个以这个定理为类型的证明**!

命题类型 `Prop` 的特殊性导致它有了类似宇宙的特点 -- 即它的元素仍然是类型, 但这些类型的元素不再是类型. 同时 `Prop` 又是 `Type` 宇宙中的元素, 因此 `Prop` 宇宙应该比 `Type` 宇宙来得低一阶. 出于一致性考虑, Lean 由此重新建立了宇宙体系 `Sort`, 其中 `Sort 0 := Prop`, `Sort 1 := Type`, ... ,`Sort (u + 1) = Type u`.

关于命题和它们的证明, 还有一件很有意思的事情. 在数学上, 当我们想使用一个定理的时候, 我们其实不太关心它是如何被证明的. 我们只需要知道这个定理被证明了, 我们就可以应用这个定理来得到想要的结论. 在 Lean 中也是如此, 我们并不想区分一个命题的两个证明, 我们也不希望不同的证明在使用的时候会带来区别. 因此, **一个命题的证明都是相等的**. 我们有如下证明:
-/

example (p : Prop) (h₁ h₂ : p) : h₁ = h₂ := by
  rfl

/-
可以看到, 对于同一个命题 `p : Prop` 的两个不同证明 `h₁` 和 `h₂`, 我们可以使用 `rfl` 来证明 `h₁ = h₂`. 这说明 `h₁` 和 `h₂` 从根本上来讲就是一样的, 因此自反策略奏效.
-/

/-
## 函数类型

为了更好地理解 Lean 中定理的叙述, 我们有必要在这里介绍函数类型.

任给两个类型 `A` 和 `B`, 我们把它们用单箭头 `→` 连接, 就可以得到一个新的类型 `A → B`. 通过这种方式得到的新类型就称为函数类型. 类型 `A → B` 中的一个元素 `f : A → B` 被称作从类型 `A` 到类型 `B` 的一个函数. 和数学上定义的函数类似, `f` 会接受一个类型为 `A` 的自变量 `a : A`, 返回一个类型为 `B` 的函数值 `f a : B`. 但是与数学上的函数用法有所区别的是, 在 Lean 中当我们表示一个函数作用在某个自变量上的时候, 我们 **不需要** 用圆括号将自变量括起来, 而是用一个空格进行分隔. 比如
-/

variable (A B : Type)
variable (a : A) (f : A → B)

/-
A → B : Type
-/
#check A → B

/-
f a : B
-/
#check f a

/-
`variable` 关键字的作用是声明一些变量. 比如这里, 我们声明了两个类型 `A` 和 `B`, 以及一个元素 `a : A` 和一个函数 `f : A → B`. 在声明后, 我们就可以在接下来的代码中使用这些声明的变量. 我们可以看到, `A → B` 确实是一个新的类型, 而 `f` 也确实可以像数学上的函数那样作用在自变量 `a` 上得到函数值 `f a`.

现在我们已经知道了如果我们拥有一个函数, 我们该如何使用它 -- 将它不加圆括号地作用在一个自变量上. 那么一个自然的问题是, 如果给定两个类型 `A` 和 `B`, 我们该如何在 Lean 中构造一个类型为 `A → B` 的函数 `f` 呢?

回想我们在数学上是如何实现这件事的: 要想定义一个函数, 我们需要给出每个自变量的取值. 在 Lean 中, 同样也是如此: 对于类型 `A` 中的每个元素 `a : A`, 我们需要决定 `f` 在 `a : A` 处取值. 这一点可以用关键字 `fun` 来做到. 具体来讲, 表达式 `fun (a : A) => f(a)` 给出了一个类型为 `A → B` 的函数. 其中, `fun` 是关键字, 表示我们将要定义一个函数; `a` 是我们引入的来自类型 `A` 的任意一个变量; 而 `f(a)` 应该是一个关于变量 `a` 的表达式, 表示函数 `f` 在 `a` 处的值.

比如, 我们可以像如下例子这样构造一个从自然数类型 `ℕ` 到其自身的函数, 将每个自然数 `n` 映射成 `n + 1`:
-/

def f₁ : ℕ → ℕ :=
  fun n => n + 1

/-
f₁ : ℕ → ℕ
-/
#check f₁

/-
3
-/
#eval f₁ 2

/-
`def` 标识符用于定义一个数学对象. 其使用格式为
```
def _定义名_ : _定义的类型_ :=
  _定义的内容_
```
我们可以这样理解这个格式: 我们要定义一个名为 `_定义名_` 的元素, 它的类型是 `_定义的类型_`, 它的具体定义是 `_定义的内容_`. 当然, 这里要求 `_定义的内容_` 的类型是 `_定义的类型_`.

`#eval` 命令的作用是 "计算" 某个表达式的值. 在这里我们可以看到, 我们所定义的 `f₁` 确实起到了 "+1" 的作用.

除了使用 `fun` 来定义函数, 我们还可以按如下的方式来定义一个函数. 我们仍用这个 "+1" 函数为例:
-/

def f₂ (n : ℕ) : ℕ :=
  n + 1

/-
f₂ (n : ℕ) : ℕ
-/
#check f₂

/-
3
-/
#eval f₂ 2

/-
在使用 `fun` 来定义函数的时候, `fun a => f(a)` 这个表达式中引入了一个自变量 `a` 作为谈论对象. 而在上面的例子中, 我们把这个引入过程提到了类型外面. 也就是说, 我们通过 `def f₂ (n : ℕ)` 这个操作先引入了一个自变量 `n : ℕ`, 然后直接定义函数在 `n` 处的值 `n + 1`. 由于提前引入了自变量, 整个定义最终的类型应该是原函数的函数值类型, 在这里也就是 `ℕ`, 定义的内容也只需是函数值对应的元素.

这种在定义名字后面通过圆括号 `()` 添加参数的行为并不陌生, 我们在第一节课介绍定理的书写时也遇到过. 从上面的例子我们可以看出, 这样的写法就是在定义一个函数, 只不过把自变量从函数类型内部提到了外面. 这对于定理书写的情形仍然适用. 实际上, 每一个定理也可以看成是一个函数, 这个定理所需的全部变量和条件都可以看作是这个函数的自变量, 而定理的最终结论则是函数值. 用更严谨的类型论语言来说, 一个定理中涉及到的所有 **元素** 和已知条件的 **证明** (注意, 这里的证明是指以某个命题为类型的元素) 都可以看作是这个函数的自变量, 而目标结论的 **证明** 则是函数值. 这表示一旦我得到了这些元素和证明, 我就可以得到目标结论的证明 -- 这完全符合我们在自然语言数学中的所作. 在这样的观点下, 像之前的 `mul_assoc` 等定理实际上都可以被看作是函数 (因此它们是某个类型的元素), 它们的类型是一个函数类型. 因而 `mul_assoc x y z` 这样的写法就可以被理解为是将自变量传入到一个函数中, 表达式的整体就是得到的函数值, 其类型也自然是 `x * y * z = x * (y * z)` 这个命题了.

有趣的是, 这样的函数似乎和我们刚刚介绍的函数不太一样. 比如 `mul_assoc 1 2 3` 的类型应该是 `1 * 2 * 3 = 1 * (2 * 3)`, 但 `mul_assoc 3 2 1` 的类型却是 `3 * 2 * 1 = 3 * (2 * 1)`. **同一个函数在不同自变量处的值的类型不同**! 这样的函数同样是一种函数, 在 Lean 中被称为**依赖函数**, 在下一节课中我们会详细介绍. 其用法和普通函数没有什么区别.

此外, 值得注意的一点是, 到目前为止我们所使用的全部都是具体的元素或证明, 而非它们类型或命题本身. 事实上, 我们在 Lean 中的操作对象 **只** 会是 **元素或证明**.
-/

/-
## 命题的蕴含 (命题间的推出关系)

实际上, 在刚才的观点中我们把命题之间的推出关系也看成了一种函数. 我们现在来更进一步地解释一下.

给定两个命题 `p q : Prop`, "`p` 推出 `q`" 这个陈述是一个命题, 它表示 "如果命题 `p` 成立, 那么命题 `q` 成立". 如果这个命题是一个真命题, 并且命题 `p` 也是一个真命题, 我们自然得到命题 `q` 是一个真命题. 从这样的角度来看, 这个命题的证明表示了一种对应关系: 如果我们有这个命题的一个证明, 那就是说这个命题本身是真命题, 从而我们可以将每个 `p` 的证明对应到一个 `q` 的证明. 而一个命题的证明都是相等的, 因此这是一个函数, 将 `p` 的证明映射到 `q` 的证明, 那么它的类型就是一个函数类型. 事实上, 这个命题的推出在 Lean 中也被记作 `p → q`, 和我们介绍的函数类型格式一致, 它的证明此时就可以被理解成是一个函数. 因此, 我们也可以像构造和使用函数一样来构造和使用 `p → q` 的证明.
-/

variable (p q : Prop)
#check p → q

example (p q : Prop) (h : p → q) (hp : p) : q :=
  h hp

/-
如上的证明过程就是完全将 `h` 当成了一个函数来使用, 将它作用于自变量 `hp : p` 上, 我们就可以得到 `q` 的证明 `h hp : q`.
-/

/-
## 显式参数与隐式参数

在介绍了函数类型之后, 我们也来介绍显式参数与隐式参数. 从上面的讲述中我们知道, `_定理名_ (_参数1_) (_参数2_) ... (_参数n_) : _证明目标_` 这样的结构可以被理解为一个函数, 比如 `mul_assoc`. 方便起见, 我们再次使用 `#check` 命令来检查 `mul_assoc` 的类型.
-/

/-
mul_assoc.{u_1} {G : Type u_1} [Semigroup G] (a b c : G) : a * b * c = a * (b * c)
-/
#check mul_assoc

/-
在第一节课中我们说到, 可以暂时跳过 `{}` 和 `[]` 中的参数. 实际上在上面的例子中我们也确实是这样做的, 比如在 `mul_assoc 1 2 3` 中, 我们提供的 `1`, `2`, `3` 分别对应了这个 "函数" 中 `a`, `b`, `c` 这三个被包在圆括号 `()` 中的变量. 这也就是说这些在圆括号中的参数是 **不能** 被跳过的, 在使用的时候必须要我们提供. 因此这些参数被称为 **显式参数**. 而与之相对地, 在花括号 `{}` 中的参数被称为 **隐式参数**, 是我们 **不能** 提供的参数, 比如 `mul_assoc` 参数中的 `G : Type u_1`. 不能手动提供并不意味着 Lean 无法知晓它们具体是什么. 实际上, Lean 会从我们提供的显式参数里来推断这些隐式参数的值. 比如 `mul_assoc 1 2 3` 这个例子, 我们提供了显式参数后, Lean 会知道 `1`, `2`, `3` 分别对应了 `a`, `b`, `c`, 而 `1`, `2`, `3` 都是自然数类型的元素, 因此 `a`, `b`, `c` 也是自然数类型的元素. 可在 `mul_assoc` 的类型中, `a`, `b`, `c` 是类型 `G` 的元素, 由此 Lean 就可以推断出, 前面不能手动提供的隐式参数 `G` 在这里就是自然数类型 `ℕ`.

至于方括号 `[]` 的用法, 大家还需耐心等待, 时机未到...
-/


/-
# 证明风格

有了全新的看待定理书写的观点, 我们再来看一个具体的定理证明的例子:
-/

example : 1 * 2 * 3 = 1 * (2 * 3) :=
  mul_assoc 1 2 3

/-
注意到, 这个证明过程和第一节课中我们介绍的证明过程有所不同. 在这个证明过程中, 我们没有用到关键字 `by`. 按照我们刚才所说, 这个证明过程当然是有意义的. 因为我们实际上只需要提供一个类型为 `1 * 2 * 3 = 1 * (2 * 3)` 的证明, 而 `mul_assoc 1 2 3` 恰好就是这个命题的一个证明, 因此 `:=` 成功地解释说明了我们需要的东西. 这种证明风格被称作 **元素风格的证明**, 意味通过函数和变量来直接构造所需的元素或证明.

那么之前介绍的 `by` 又在证明过程中起到什么作用呢? 事实上, 使用了 `by` 的证明风格被称作 **策略风格的证明**, 这是因为 `by` 是开启策略模式的关键字, 只有开启了策略模式, 我们才能够上节课介绍的 `rw`, `rfl` 等策略. 此外, 一旦开启了策略模式, 我们就没办法通过直接写下所需的目标元素来完成证明. 比如:
-/

example : 1 * 2 * 3 = 1 * (2 * 3) := by
  /-
  error message: unknown tactic
  -/
  -- mul_assoc 1 2 3
  rw [mul_assoc]

/-
可以看到, 如果我们想像元素风格证明那样在策略模式中直接写下所需的证明, Lean 会抛出一个错误 -- 未知策略. 这就是说我们在策略模式中只能使用各种策略来逐步证明.

同样地, 策略风格的证明仍然遵守 Curry-Howard correspondence, 即我们通过 `by` 和一系列策略构造出的证明过程仍然是目标命题的一个证明. 比如我们可以使用 `#check` 命令来检查这样一个表达式:
-/

#check (by rw [mul_assoc] : 1 * 2 * 3 = 1 * (2 * 3))

/-
可以看到, 这段代码通过了 Lean 的检查, 并没有任何错误信息. 因此,
```
by rw [mul_assoc]
```
这段代码确实充当了命题 `1 * 2 * 3 = 1 * (2 * 3)` 的一个证明.
-/


/-
# `exact` 策略和 `refine` 策略

为了在策略模式中通过直接给出所需的元素来完成证明, 我们可以使用 `exact` 策略. 其使用方法十分简单, 当我们可以直接构造出元素 `x : t` 使得 `x` 的类型 `t` 恰好是我们所需的目标类型时, 我们可以使用 `exact x` 来完成证明.

比如上面的例子:
-/

example : 1 * 2 * 3 = 1 * (2 * 3) := by
  exact mul_assoc 1 2 3

/-
当然, 我们也可以使用改写策略来完成这个证明:
-/

example : 1 * 2 * 3 = 1 * (2 * 3) := by
  rw [mul_assoc]

/-
接下来我们介绍 `refine` 策略. `refine` 可以被概括为是 "挖了洞的 `exact`". 我们用一个稍复杂些的例子来理解这一点:
-/

open Real

#check add_pos
#check zero_lt_one
#check exp_pos
#check add_le_add_left
#check exp_le_exp_of_le
#check log_le_log
example {a b : ℝ} (h : a ≤ b) : log (1 + exp a) ≤ log (1 + exp b) := by
  exact log_le_log
    (add_pos zero_lt_one (exp_pos _))
      (add_le_add_left (exp_le_exp_of_le h) 1)

/-
在解释这个例子之前, 我们注意到第 314 行的 `open Real`. 实际上这就是命名空间的使用方法. 之前我们提过, 为了避免重名现象的发生, 我们使用命名空间给一些可能重名的定义或定理加上前缀, 以作区分. 但当我们确保接下来的代码中不会出现因重名而产生的歧义时, 我们可以使用 `open _命名空间的名字_` 来打开某个命名空间, 这样我们就可以在接下来的代码中省略这个命名空间的前缀. 比如上述例子中用到的 `exp`, `log`, `exp_pos` 等都在 `Real` 命名空间中, 但我们 `open Real` 之后就可以直接使用了.

在这个例子中, 我们想要证明 `log (1 + exp a) ≤ log (1 + exp b)`. 为了证明这一点, 我们希望使用定理 `log_le_log`, 这个定理需要我们提供两个命题的证明, 分别是 `hx : 0 < x` 和 `hxy : x ≤ y`, 然后才能得到 `log x ≤ log y` 的证明. (受限于篇幅原因, 我们没有在上方的代码中展示出来 `#check` 的结果, 大家可以自行查看.) 对于这道题目来说, 这要求我们提供 `0 < 1 + exp a` 和 `1 + exp a ≤ 1 + exp b` 的证明. 因此如果我们使用 `exact` 策略来完成证明, 那么证明过程应该初步写成 `exact log_le_log (...) (...)`, 这里第一个括号应该填入 `0 < 1 + exp a` 的证明, 第二个括号应该填入 `1 + exp a ≤ 1 + exp b` 的证明.

接下来我们需要想办法构造一个 `0 < 1 + exp a` 的证明. 在这一步, 我们使用的定理是 `add_pos`. 为此我们还需要 `0 < 1` 的证明和 `0 < exp a` 的证明. 这可以由 `zero_lt_one` 和 `exp_pos` 来做到.

另外一个部分就是构造一个 `1 + exp a ≤ 1 + exp b` 的证明. 我们利用定理 `add_le_add_left`, 只需提供命题 `exp a ≤ exp b` 的证明即可. 这一步又可以由定理 `exp_le_exp_of_le` 来实现. 大家可以仔细琢磨上面的示例代码来更好地理解整个过程.

此外, 细心的同学或许会注意到, 在提供命题 `0 < exp a` 的证明时, 我们本应该用 `exp_pos a` 来做到这一点. 但示例代码中用的却是 `exp_pos _`, 并没有提供 `a` 作为参数, 这似乎与之前所述的 "需要提供显式参数" 有所出入. 实际上, 下划线 `_` 在 Lean 中充当占位符的角色, 在函数传参的过程中, 我们也可以使用下划线来顶替某些参数. 这时候 Lean 会去尝试自行推断这些参数应该是什么. 比如这里, 我们的证明目标是 `log (1 + exp a) ≤ log (1 + exp b)`, 而我们使用的定理是 `log_le_log`, Lean 这时就会知道 `log_le_log` 后面第一个参数代表的命题应该是 `0 < 1 + exp a`. 而第一个参数又使用了 `add_pos`, 因此 Lean 又会推断出 `add_pos` 的第二个参数应该代表命题 `0 < exp a`. 而我们用 `exp_pos _` 来构造这个命题的证明, 所以 Lean 最终推断出 `_` 代表的元素应该是 `a`. Lean 成功推断出想要的结果, 并将该参数自动补上, 证明就可以顺利进行. 但需要注意的是, 这样的下划线 `_` 只能顶替一些 **非证明的元素**, Lean 只会自动填充非证明的元素. 比如将上面例子中 `exp_le_exp_of_le h` 当中的 `h` 换成下划线, 你会发现 Lean 仍然能够推断出 `h` 所在的位置所需元素的类型. 但因为所需元素是一个命题的证明, 所以 Lean 无法自动填充这个证明.

现在让我们再说回 `refine`. 刚刚提到, `refine` 是被 "挖了洞的 `exact`". 这就是说, 我们首先可以像使用 `exact` 那样使用 `refine` -- 这相当于没有挖洞.
-/

example {a b : ℝ} (h : a ≤ b) : log (1 + exp a) ≤ log (1 + exp b) := by
  refine log_le_log
    (add_pos zero_lt_one (exp_pos _))
      (add_le_add_left (exp_le_exp_of_le h) 1)

/-
在这样的基础上, 我们可以开始挖洞. 所谓挖洞, 就是指将所构造的证明中的某一部分先空出来, 稍后再提供. 比如下面这个例子, 我们将 `log_le_log` 中需要的两个参数全部挖掉, 用 `?_` 代替. Lean 就会知道, 我们想用 `log_le_log` 来构造证明, 同时被挖掉的两个参数分别应该代表 `0 < 1 + exp a` 和 `1 + exp a ≤ 1 + exp b` 这两个命题. 但是因为我们挖了洞, 所以 Lean 会生成两个新的目标让我们分别证明这两个命题.
-/

example {a b : ℝ} (h : a ≤ b) : log (1 + exp a) ≤ log (1 + exp b) := by
  refine log_le_log ?_ ?_
  · /-
      case refine_1
      A B : Type
      a✝ : A
      f : A → B
      a b : ℝ
      h : a ≤ b
      ⊢ 0 < 1 + rexp a
    -/
    exact add_pos zero_lt_one (exp_pos _)
  · /-
      case refine_2
      A B : Type
      a✝ : A
      f : A → B
      a b : ℝ
      h : a ≤ b
      ⊢ 1 + rexp a ≤ 1 + rexp b
    -/
    exact add_le_add_left (exp_le_exp_of_le h) 1

/-
当产生了多个目标的时候, 我们需要使用 `·` 符号来对每一个目标进行分点证明. `·` 可以帮助我们在信息窗口中只聚焦于当前目标, 能够使代码整体结构变得更加清晰, 提高可读性.

从上面的例子可以看出, `refine` 和 `exact` 的原理没有什么区别. 它同样希望我们能够直接提供一个所需的证明, 只不过允许我们先省略掉其中的一些参数, 稍后再提供. 实际上, `refine` 可以被广泛用于 "要证...只需证..." 的情形. 即像上面的例子一样, 我们可以用一个 `h : 充分条件 → 结论` 的定理来得到我们想要的结论, 只需要使用 `refine h ?_` 就可以把我们要证明的目标从当前 `结论` 变为那个 `充分条件`.

同时我们也需要注意到, `refine` 挖掉的洞应该是一些 "好" 的洞. `refine` 允许我们稍后再证明这些洞, 那首先需要 Lean 能够推断出这些洞的类型是什么. 像上文的例子, 我们挖掉的是 `log_le_log` 的两个参数, 而 `log_le_log` 最终的结论是 `log x ≤ log y`, Lean 能够从中推断出 `x` 和 `y` 具体的值, 从而也就能够推断出挖掉的两个洞所代表的命题到底是什么. 而有些时候, 如果我们挖掉了太多的洞, Lean 就无法做到这一点. 比如下面这个例子:
-/

/- Bad `refine` example -/
example : 1 ≤ 5 := by
  /-
    don't know how to synthesize implicit argument 'b'
    @le_trans ℝ instPreorder a ?m.10457 c ?m.10459 ?m.10460
  -/
  -- refine le_trans ?_ ?_
  sorry

/-
不难发现, `le_trans` 这个定理中的 `a`, `b`, `c` 三个参数全部都是隐式参数, 它们不需要我们手动提供, 而是从后面的参数 `hab : a ≤ b` 和 `hbc : b ≤ c` 中推断. 但这里我们将这两个证明全部挖掉, 这时 Lean 知道的信息就只有: 要证明的目标是 `1 ≤ 5`, 使用的定理是不等号的传递性 `le_trans`. 由此 Lean 能够推断出 `le_trans` 中参数 `a` 和 `c` 分别是 `1` 和 `5`, 但并不知道参数 `b` 的值应该是多少. 所以它向我们抱怨 "无法合成出隐式参数 `b`". 因此这是一个 "坏" 的挖洞. 在使用 `refine` 的时候我们应该尽量避免这一点.

通过上述的这些例子我们也能够注意到, 与直接构造目标元素的元素风格不同, 策略的作用是逐步改变证明目标, 直到它变的不那么复杂. 比如 `refine`, 它先通过合适的定理将目标转化为充分条件, 然后再逐步证明这些充分条件最终完成证明.
-/


/-
# Lean 中的命名原则

在本节的最后, 我们来介绍一下 Lean 中的命名原则. 我们不在这里谈论命名格式上的问题, 而只谈论如何用合适的缩写来表达定理的含义. Lean 中的命名原则基本遵守以下几条:
1. 按照缩写惯例, 可以用某些专有名词直接概括.
2. 按照缩写惯例, 将命题从左至右依次读出.
3. 结论在前, 条件在后, 中间用 "of" 进行分隔.

举个例子, 我们之前常常用到的 `mul_assoc` 就遵守第一条. `mul` 是乘法的缩写惯例, `assoc` 是结合律的缩写惯例. `mul_assoc` 代表的命题是 `a * b * c = a * (b * c)`, 表示乘法结合律, 这是一个专有名词, 因此记作 `mul_assoc`. 刚刚提到的 `le_trans` 也属于这点.

而上文提到的 `add_pos`, `zero_lt_one`, `exp_pos`, `add_le_add_left` 和 `log_le_log` 等都遵守第二条. 比如 `add_pos`, `add` 是加法的缩写惯例, `pos` 是大于零的缩写惯例, 它代表的命题是 `0 < a + b`, 即 "加起来大于零", 因此从左到右依次读出就是 `add_pos`. `zero_lt_one`, `exp_pos`, `log_le_log` 也是同理. 稍微有些区别的是 `add_le_add_left`. 按照之前的说法, 该定理表示的命题是 `a + b ≤ a + c`, 从这里我们可以理解 `add_le_add` 的由来. 但这个定理实际上表示的是不等号两端加法表达式中左边一项相同的情形, 因此在 `add_le_add` 的右边加上了一个 `left` 以作区分.
-/

/-
add_le_add_right.{u_1} {α : Type u_1} [Add α] [LE α] [i : AddRightMono α] {b c : α} (bc : b ≤ c) (a : α) : b + a ≤ c + a
-/
#check add_le_add_right

/-
遵守最后一条的命名也可以从刚刚的例子中找到 -- `exp_le_exp_of_le`. 结论的主体是 `exp_le_exp`, 而得到这个结论需要的条件是 `x ≤ y`, 我们用缩写惯例 `le` 来表示小于或等于关系. 因此按照第三条, 这个定理的名字就叫做 `exp_le_exp_of_le`. 一般来讲, 如果一个定理依赖了多个条件, 其命名应为 `结论_of_条件1_of_条件2_of_..._of_条件n`, 其中 `条件1` 到 `条件n` 应该按照定理中参数顺序从左到右依次书写.

有了命名法, 大家就可以尝试在 Mathlib 的官方文档中搜索自己想要的定理了.
-/

#leansearch "if a>0 and b>0 then a+b>0?"

/-
# 随堂练习

请利用所给定理, 通过使用合适的策略完成证明.
-/

#check abs_le_of_sq_le_sq
example (a b : ℝ) (h : a ^ 2 ≤ b ^ 2) (hb : 0 ≤ b) : |a| ≤ b := by
  exact abs_le_of_sq_le_sq h hb

#check dvd_mul_of_dvd_left
#check dvd_mul_left
example (x y z : ℤ) : x ∣ y * x * z := by
  exact dvd_mul_of_dvd_left (dvd_mul_left x y) z


#check le_antisymm
#check le_min
#check min_le_left
#check min_le_right
#check le_trans
example (a b c : ℝ) : min (min a b) c = min a (min b c) := by
  refine le_antisymm ?_ ?_
  · exact le_min (le_trans (min_le_left (min a b) c) (min_le_left a b)) (le_min (le_trans (min_le_left (min a b) c) (min_le_right a b)) (min_le_right (min a b) c))

  · exact le_min (le_min (min_le_left a (min b c)) (le_trans (min_le_right a (min b c)) (min_le_left b c))) (le_trans (min_le_right a (min b c)) (min_le_right b c))


/-
# Appendix I: Lean 中 Girard 悖论的证明 [¹]
-/

#check Counterexample.girard
#print Counterexample.girard



open Real
#check add_lt_add_right
#check add_lt_add_of_le_of_lt
#check exp_lt_exp_of_lt
example (a b c d e : ℝ) (h₀ : a ≤ b) (h₁ : c < d) : a + exp c + e < b + exp d + e := by
  refine add_lt_add_right ?_ e
  · exact add_lt_add_of_le_of_lt h₀ (exp_lt_exp_of_lt h₁)


#check dvd_add
#check dvd_mul_of_dvd_right
#check dvd_mul_right
#check pow_two
example (x y z w : ℤ) (h : x ∣ w) : x ∣ y * (x * z) + x ^ 2 + w ^ 2 := by
  repeat rw [pow_two]
  refine dvd_add (dvd_add ?_ ?_) ?_
  · exact (dvd_mul_of_dvd_right (dvd_mul_right x z) y)
  · exact dvd_mul_right x x
  · exact dvd_mul_of_dvd_right h w


#check le_antisymm
#check le_min
#check min_le_left
#check min_le_right
example (a b : ℝ) : min a b = min b a := by
  refine le_antisymm ?_ ?_
  · exact le_min (min_le_right a b) (min_le_left a b)
  · exact le_min (min_le_right b a) (min_le_left b a)


#check lt_of_le_of_lt
#check lt_trans
example (a b c d e : ℝ) (h₀ : a ≤ b) (h₁ : b < c) (h₂ : c ≤ d) (h₃ : d < e) : a < e := by
  exact lt_trans (lt_of_le_of_lt h₀ h₁) (lt_of_le_of_lt h₂ h₃)


open Real
#check sub_le_sub_left
#check exp_le_exp_of_le
example (a b c : ℝ) (h : a ≤ b) : c - exp b ≤ c - exp a := by
  exact sub_le_sub_left (exp_le_exp_of_le h) c


#check le_antisymm
#check add_le_add_right
#check min_le_left
#check min_le_right
#check le_add_of_sub_left_le
#check sub_left_le_of_le_add
example (a b c : ℝ) : c + min a b = min (c + a) (c + b) := by
  refine le_antisymm ?_ ?_
  · apply le_min
    · exact add_le_add_left (min_le_left a b) c
    · exact add_le_add_left (min_le_right a b) c
  · have h : min (c + a) (c + b) - c ≤ min a b := by
      apply le_min
      · exact sub_left_le_of_le_add (min_le_left (c + a) (c + b))
      · exact sub_left_le_of_le_add (min_le_right (c + a) (c + b))
    refine le_add_of_sub_left_le h



-- c + min a b ≤ min (c + a) (c + b)
-- min a b ≤ min (c + a) (c + b) - c
  -- min a b ≤ (c + a) - c = a
  -- min a b ≤ (c + b) - c = b.
