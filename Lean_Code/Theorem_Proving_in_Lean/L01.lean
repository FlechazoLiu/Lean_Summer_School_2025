import Mathlib

/-
# 引入

在第一节课中, 我们通过一些例子和实操来对在 Lean 中进行定理证明有一个基本的认识.

我们首先来看下面这个例子:
-/

theorem example_for_rewriting (a b c d e f : ℝ) (h₁ : a * b = c * d) (h₂ : e = f) : a * (b * e) = c * (d * f) := by
  sorry

/-
我们通过这个例子来展示 Lean 中定理的书写方式, 其通用结构如下:
```
theorem _定理名_ (_参数1_) (_参数2_) ... (_参数n_) : _定理最终结论_ := by
  _定理证明过程_
```

其中各部分的用途分别是:
• `theorem` 是 Lean 中的标识符, 它表示接下来书写的内容是一个定理.
• `_定理名_` 是 `theorem` 标识符后 **不可缺少** 的部分, 我们可以通过引用所需定理的名字来使用该定理. 定理名应当能很大程度上反映出定理的内容并需要遵循一定的规则, 在后面的课程中我们会更加详细地进行介绍.
  比如上面的例子中, 我们的定理叫做 `example_for_rewriting`, 意为"用于展示改写的例子".
• `_参数_` 包含了定理陈述中涉及到的一系列变量和命题条件, 每个参数都用括号分别包起来. 参数的书写格式应遵循 `(_参数名_ : _参数内容_)` 这样的格式.
  · 如果该参数是某个变量而非命题条件, 那么其参数内容应该是该参数所属的集合. 比如上面例子中的 `a`, `b`, ... `f`, 其参数内容是 `ℝ`, 实数集. 这就是说它们是若干个实数. 特别地, 如果若干变量来自于同一个集合, 它们会被并列写在同一行, 用空格分隔.
  · 如果该参数代表的是一个命题条件, 那么其参数内容应该是其代表的这个条件. 比如上面例子中的 `h₁` 和 `h₂`, 它们分别代表 `a * b = c * d` 和 `e = f` 这两个命题条件.
• `:` 作为定理条件叙述和最终结论之间的分隔符. 就是说, 冒号前面的部分是定理需要的全部参数, 冒号后面的部分则是定理的结论. 比如上面的例子中, 该定理的最终结论是等式 `a * (b * e) = c * (d * f)` 成立.
• `:= by` 是另一个分隔符, 用于分隔定理叙述和其证明. 就是说, `:= by` 前面的部分包含了定理的条件和最终结论, 后面的部分则是定理的证明过程.
• `sorry` 是一个关键字, 用于定理的证明部分. 它的作用相等于告诉 Lean, "我暂时跳过这个命题不去证明". 这听起来有些作弊, 因此 Lean 会在使用了 `sorry` 的定理上抛出一个警告, 即上面例子中的 `⚠` 符号.

总结一下, 这个例子代表的定理是"给定 `a` 到 `f` 若干个实数, 已知 `a * b = c * d` 并且 `e = f`, 求证: `a * (b * e) = c * (d * f)`.".
-/

/-
## unicode 字符编码

在上面的例子中, 命题条件 `h₁` 和 `h₂` 的名字中含有角标 `₁`, `₂`. 这些角标在 Lean 中是特殊字符, 使用 unicode 编码, 需要用反斜线 `\` 加上对应的编码打出.

对于在代码中出现的特殊字符, 可以通过将光标悬停在该字符上来查看如何打出该字符; 对于未曾见过的特殊字符, 可以通过在 vscode 中按下 f1 键, 并在出现的文本框中输入 "Lean 4: Docs: Show Unicode Input Abbreviations" (可以只输入 unicode, 并在关联出的选项中选择该项) 来查看所有特殊字符的编码.
-/


/-
# 信息窗口 (infoview)

在介绍如何证明上述定理之前, 我们还需要熟悉一下 Lean 的使用界面.

和其他编程语言类似, 在本栏的左边是文件目录, 而本栏则是书写代码的地方. 但有所不同的是, 在本栏的右边还有一个窗口, 显示了一些其他信息. 这个窗口就被称作信息窗口.

作为定理证明器, Lean 的优势之一就是其交互性. 所谓交互性, 是指 Lean 不像大多数编程语言一样, 需要完全写好代码并编译运行时才会报告错误, 而是在写代码的过程中就会实时的报告代码当中的错误. 信息窗口就是将这一实时过程展现出来的地方.

当我们将光标放在一个位置的时候, 信息窗口会反映出光标所属位置之前的局部代码信息.

比如在上面的例子中, 我们将光标放在 `:= by` 后面, 会在信息窗口中看到如下内容:
```
1 goal
a b c d e f : ℝ
h₁ : a * b = c * d
h₂ : e = f
⊢ a * (b * e) = c * (d * f)
```
结合刚才所说的, 到 `:= by` 位置, 该代码块包含了定理的变量、条件和结论叙述, 因此信息窗口中反映出了这些内容: `1 goal` 表示我们需要证明结论的数量是一个, 下面黄色加粗的部分表示我们已知的数学对象或者命题条件, 而最后一行 `⊢` 符号之后的部分则表示定理的最终结论.

如果我们再把光标放在 `sorry` 后面, 我们会在信息窗口中看到如下内容:
```
No goals
```
这实际上表示我们已经证明了所需结论, 所以没有目标需要再去证明了.

但你可能会有疑惑, 我们明明是用 `sorry` 告诉 Lean 暂时跳过证明, 怎么在 Lean 的眼中就变成我们已经证明结论了呢? 实际上, 把光标放在定理名 `example_for_rewriting` 的后面, 或是像刚刚一样将光标放在 `:= by` 的后面, 我们可以发现, 在信息窗口中还有这样一条信息:
```
declaration uses 'sorry'
```
这就是刚刚提到的 Lean 给我们抛出的警告, 说的是该定理的证明过程中用到了 `sorry`. 因此 `sorry` 的使用机制如下: Lean 会大方地允许使用了 `sorry` 的定理通过检查, 但是这些定理会被标记来提醒程序员. 在这样的机制下, 一个被认为是正确的命题证明中应当 **不包含** `sorry`.

在接下来的证明过程讲解中, 我们可以看到, 随着证明不断进行, 信息窗口中的证明目标也会不断变化.
-/


/-
# 定理证明的书写

让我们在回到最初的例子, 现在我们介绍如何证明这个定理. 首先我们来展示这个定理的证明过程:
-/

theorem example_for_rewriting' (a b c d e f : ℝ) (h₁ : a * b = c * d) (h₂ : e = f) : a * (b * e) = c * (d * f) := by
  rw [h₂]
  rw [← mul_assoc a b f]
  rw [h₁]
  rw [mul_assoc c d f]

/-
## `#check` 命令

可以看到, 我们使用一些语句完成了这个定理的证明. 在讲解这些语句之前, 让我们介绍一个命令 `#check`.
-/

/-
mul_assoc.{u_1} {G : Type u_1} [Semigroup G] (a b c : G) : a * b * c = a * (b * c)
-/
#check mul_assoc

/-
`#check _定理名字_` 的作用是检查该定理名字所代表的定理内容. 比如上面的例子中, 我们检查了一个名为 `mul_assoc` 的定理, 将光标放在 `#check mul_assoc` 的后面, 我们可以在右侧的信息窗口中看到这个定理的内容.

类似地, 通过检查得到的定理信息仍然包含几个部分 -- 定理名、参数、最终结论. `mul_assoc` 就是这个定理的名字, `{G : Type u_1} [Semigroup G] (a b c : G)` 就是这个定理需要的参数, `a * b * c = a * (b * c)` 则是这个定理的最终结论.

注意到, 在 `mul_assoc` 的信息中, 存在一些不同于圆括号的括号 -- `{}` 和 `[]`. 在现在的阶段中, 我们可以暂时跳过这些括号, 不理会其中的含义, 后面的课程中会逐步解释它们和圆括号 `()` 之间的差异.

跳过了这些陌生的括号后, 我们现在可以看出 `mul_assoc` 这条定理所代表的含义了 -- "设 `a`, `b`, `c` 是来自于集合 `G` 的三个元素, 那么 `a * b * c = a * (b * c)`.", 实际上, `mul_assoc` 是 multiplication associativiy 的简写, 代表乘法结合律.

不难看出, 上述定理中的集合 `G` 需要满足一些性质, 比如我们需要 `G` 上定义了乘法, 并且这个乘法满足结合律, 上述定理才能成立. 这些性质被 `{}` 和 `[]` 中的内容所保证 (比如 `[]` 中的 `[Semigroup G]` 赋予了 `G` 一个半群结构, 这实际上就保证了上述要求). 因此目前来讲, 我们只需要知道当集合 `G` 满足一些比较好的条件的时候, 我们就可以用 `mul_assoc` 来表示乘法结合律. 特别地, 本节课最开始提到的实数集 `ℝ` 当然应该满足这些性质, 因此我们可以对实数集 `ℝ` 中的元素使用这个定理.

这样的一个定理表述的是最通用的情况, 即集合 `G` 可以是任何 "性质好" 的集合, `a`, `b`, `c` 可以是集合 `G` 中的任意三个元素. 当我们使用一个定理的时候, 我们往往需要将它应用于某个或者某些具体的对象上. 比如任给三个实数 `x y z : ℝ`, 我们希望能够得到 `x * y * z = x * (y * z)` 这个定理， 这显然需要用到 `mul_assoc`. 为了实现这一点, 我们只需要将 `mul_assoc` 这个定理中所需的参数给它即可 (别忘了我们暂时忽略了 `{}` 和 `[]` 中的参数, 因此只需要给它圆括号 `()` 中的参数). 也就是说 `mul_assoc x y z` 就代表了等式 `x * y * z = x * (y * z)`.
-/

/-
## 运算符的结合

在 `mul_assoc` 的例子中还有一个容易被忽略的疑点 -- 运算符的结合. 当我们在 Lean 中看到表达式 `a * b * c` 的时候, 我们该如何判断这个表达式的结合方式, 究竟是 `a * b` 先运算? 还是 `b * c` 先运算?

很幸运, 从上面的讲解中我们可以看出, 表达式 `a * b * c` 的结合方式遵循了自然语言数学的传统, 其结合顺序是从左到右的. 因此, `a * b * c` 实际上表示的是 `(a * b) * c`, 但和自然语言数学一样, 对于左结合的运算符 `*`, 加在左边第一项的括号按惯例是省略的.

在 Lean 中, 我们有时候会看到各种各样奇奇怪怪的运算符号, 也很可能不知道它们的运算顺序. Lean 实际上为我们提供了一种方法来查看某个运算符号所结合的项. 比如, 将光标放在 `#check mul_assoc` 后面, 我们可以在信息窗口中看到表达式 `a * b * c`; 再将鼠标悬停在第一个乘号上面, 可以看到 `a * b` 这一项被蓝色阴影覆盖住了, 这说明第一个乘号结合了 `a` 和 `b` 这两项. 与之相对地, 如果将鼠标悬停在第二个乘号上面, 可以看到整个表达式 `a * b * c` 都被蓝色阴影覆盖住了, 这说明第二个乘号结合的是 `a * b` 这一项和 `c` 这一项.
-/

theorem example_for_rewriting'' (a b c d e f : ℝ) (h₁ : a * b = c * d) (h₂ : e = f) : a * (b * e) = c * (d * f) := by
  rw [h₂]
  rw [← mul_assoc a b f]
  rw [h₁]
  rw [mul_assoc c d f]

/-
## 改写策略 `rw []` 的使用

又说了这么多, 让我们再次回到例题的证明过程上. 为了方便大家边看证明代码边阅读这段文字, 我们在上方又重新证明了一遍该定理.

这道题目的证明过程, 主要使用了改写策略 `rw`. 所谓策略 (Eng. tactic), 是帮助我们进行定理证明的特殊语句. `rw` 是 rewrite 的缩写, 意为做改写, 能够通过等式将某个表达式改写成另一个表达式.

`rw` 的使用格式为 `rw [_命题条件_]`, 这里要求所用的命题条件一定是一个 **等式**. `rw` 会对证明目标进行改写, 它会在证明目标中搜寻所用的命题条件中等号左边的部分, 将其改为等号右边的部分.

比如上面第 129 行的证明过程, 我们使用 `rw [h₂]` 对目标进行改写. 所用的命题条件 `h₂` 代表着等式 `e = f`, 所以 `rw` 会在目标中搜寻 `h₂` 所代表的等式等号左边的部分, 也就是 `e`, 并将它替换成等号右边的 `f`. 因此如果我们把光标放在这一行的末尾, 我们可以看到在信息窗口中, 我们需要证明的目标结论就变成了
```
⊢ a * (b * f) = c * (d * f)
```
可以看到, 原本等号左边的 `a * (b * e)` 这个表达式已经被改写成 `a * (b * f)` 了.

在接下来的证明中, 我们最终希望能够将 `a * b` 通过等式 `h₁` 替换成 `c * d`, 从而把等式两边变得一模一样. 但为了做到这一点, 我们需要先反过来使用乘法结合律将 `a * (b * e)` 变为 `a * b * e`, 然后才能做替换. 这是因为在反过来使用乘法结合律之前, 我们的目标等式中并没有 `a * b` 这个表达式, 因此也就无从通过 `h₁` 做替换了.

但我们之前提到的 `rw` 用法, 只能在目标中将所用等式的左边部分替换成右边部分. 而眼下我们需要将 `a * (b * f)` 替换成 `a * b * f`, 但之前介绍的 `mul_assoc a b f` 所代表的命题条件是 `a * b * f = a * (b * f)`, 因此我们需要反过来使用 `rw`, 也就是在目标中将所用等式的右边部分替换成左边部分. 为此, 我们只需要在所用的定理名字前面加上左箭头 `←` 符号就可以了. 比如上面例子中的 `rw [← mul_assoc a b f]`.

接下来的两步与之前的讲解类似, 大家可以自行理解.

此外, `rw` 还允许我们连着做改写, 即我们可以用 `rw [_命题条件1_, _命题条件2_, ..., _命题条件n_]` 的格式将多个 `rw []` 合并为一个. 比如上面的例子也可以按如下格式证明:
-/

theorem example_for_rewriting''' (a b c d e f : ℝ) (h₁ : a * b = c * d) (h₂ : e = f) : a * (b * e) = c * (d * f) := by
  rw [h₂, ← mul_assoc a b f, h₁]
  rw [mul_assoc c d f]

/-
`rw` 还支持更为强大的功能 -- 格式匹配. 举个例子, 如果我们为 `mul_assoc` 提供全部的变量, 即像 `mul_assoc x y z` 这样的情况, 那么毫无疑问它所代表的命题条件就是 `x * y * z = x * (y * z)`.

但如果我们只提供一部分参数, 比如 `mul_assoc x y` 这样的情况, 那么此时它所代表的命题条件就变成了 `x * y * _ = x * (y * _)`, 这里的 `_` 起到占位符的作用, 表示待定的意思.

实际上, 像 `mul_assoc x y` 这样只有部分的命题条件也可以应用于 `rw` 中. 这时候 `rw` 仍会在目标中搜寻形如 `x * y * _` 的表达式, 占位符的部分可以填入任何变量.

比如下面的例子中, `mul_assoc a` 代表了 `a * _ * _ = a * (_ * _)` 这样一个命题条件, 因此 `rw` 会在目标中搜寻形如 `a * _ * _` 的表达式. 在目标中, 这样的表达式共有两个, 分别是 `a * b * c` 和 `a * e * f`, `rw` 会选择第一个匹配到的表达式并将其改写成 `a * (_ * _)` 的形式, 在这里也就是 `a * (b * c)`.
-/

theorem example_for_rewriting_matching (a b c d e f : ℝ) (h : b * c = e * f) : a * b * c * d = a * e * f * d := by
  rw [mul_assoc a]
  rw [h]
  rw [← mul_assoc]

/-
在第 175 行中, 我们只使用了 `mul_assoc` 这个定理本身, 没有为其添加任何的变量参数, 这时 `rw` 会尝试匹配一切形如 `_ * _ * _` 的表达式, 并将遇到的第一个表达式改写.

此外, 这样的部分命题条件也支持使用占位符, 比如 `mul_assoc _ b` 所代表的命题条件就是 `_ * b * _ = _ * (b * _)`. 下面就是一个这样应用的例子.
-/

theorem example_for_rewriting_matching' (a b c d e f : ℝ) (h : b * c = e * f) : a * b * c * d = a * e * f * d := by
  rw [mul_assoc _ b]
  rw [h]
  rw [← mul_assoc]

/-
在上面的例子中, `rw` 都是在我们要证明的目标上做改写. 实际上, `rw` 也允许我们在条件上做改写. 只需要在 `rw [_命题条件_]` 后面加上 `at _条件名_` 即可. 比如下面的例子:
-/

theorem rewriting_at_conditions (x y : ℝ) (h₁ : x = 0) (h₂ : x = y) : y = 0 := by
  rw [h₁] at h₂
  rw [← h₂]

/-
在上面的例子中, 我们当然可以直接使用 `rw [← h₂, h₁]` 来完成证明. 但我们也可以先在条件 `h₂` 上做改写, 将 `x` 改写成 `0`, 然后再在目标上完成最终的改写.
-/


/-
## 命名空间

大家可能注意到, 上面第一个作为例子的定理叫做 `example_for_rewriting`, 但随后的两次出现, 它的名字一直在变化, 分别叫做 `example_for_rewriting'` 和 `example_for_rewriting''`. 这样做是因为 Lean 中不允许出现同名的两个定理, 即使它们从叙述到证明都完全一样. 因此为了区分, 往往需要在定理后面加上 `'`, 或是 `₁`, `₂` 这样的角标.

但这并不是一个好方法. 我们需要一套更规范的方法来为同名的定理/定义做区分 -- 这就是命名空间.

举个例子, 我们既可以在自然数集上定义加法, 也可以在 (域上的) 向量空间里定义加法. 但很明显, 虽然它们的名字都叫加法, 但其定义却大不相同. 为了更好地区分它们, 而不是把它们粗略地叫做 "加法1", "加法2", 我们可以引入一些特征加以命名.

比如我们可以管自然数集上的加法叫 "自然数加法"，管向量空间上的加法叫 "向量加法". 为了使这种命名方式更具有一致性, 我们在名字中间进行分隔: 把 "自然数加法" 记作 "自然数.加法", 把 "向量加法" 记作 "向量.加法" .

这样做一方面可以使命名结构更加清晰, 即名字的主体是 "." 后面的内容 -- 加法, 而 "." 前面的内容则起到修饰作用, 说明这个加法是谁的加法, 是怎么样的加法; 另一方面, 在定义更多具有相同名字的内容时, 比如乘法, 数乘等, 我们仍然可以采用这样一种结构, 这种方法具有普适性.

在 Lean 中, 我们用 **命名空间** 这一概念来表示上述命名方法. 具体来讲, 我们把上述命名法中 "." 前面的部分叫做命名空间, 一个命名空间可以被看作是一个版块, 命名空间里的内容是这个版块包含的属性. 比如, 有一个命名空间叫做 `Nat`, 从名字可以看出, 这个命名空间和自然数相关. 实际上, 这个命名空间可以被理解为自然数版块, 而这个命名空间里的定义、定理等, 比如 `Nat.add`, `Nat.mul_assoc` 等, 都可以看成是自然数的一些属性, 或者说相关内容、性质.

下面我们分别以自然数集和整数集上的乘法结合律为例, 来展示 Lean 中对同名定理的区分.
-/

/-
Nat.mul_assoc (n m k : ℕ) : n * m * k = n * (m * k)
-/
#check Nat.mul_assoc

/-
Int.mul_assoc (a b c : ℤ) : a * b * c = a * (b * c)
-/
#check Int.mul_assoc

/-
这里 `Nat` 就是我们刚刚提到的自然数相关的命名空间, 而 `Int` 则代表了整数相关的命名空间.

关于如何创造一个命名空间, 如何使用一个命名空间这些问题, 我们在后面的课程中会择机介绍.
-/

/-
## Mathlib 数学定理库

就像我们在自然语言的数学世界中做的那样, 公开的数学成果被每个人所共享, 在 Lean 中也应该有这样一个数学定理共享库, 这就是 Mathlib.

像上文提到的 `mul_assoc`, `Nat.mul_assoc`, `Int.mul_assoc` 这些定理都被储存在 Mathlib 数学定理库中. 我们在代码开头写下的 `import Mathlib` 其实就相当于告诉 Lean, 我下面书写的代码可以直接引用 Mathlib 数学定理库中的内容.

有了这样一个定理库, 我们就可以 "站在巨人的肩膀上看世界".

该定理库的链接为 `https://leanprover-community.github.io/mathlib4_docs//`. 大家可以先自行浏览探索, 在下节课中我们会介绍定理的命名规则以及如何在定理库中检索需要的定理.
-/

/-
## 自反策略 `rfl` 的使用

在本节课的最后, 我们来介绍另一个策略 -- 自反策略 `rfl`. 为此, 我们先来看一个例子:
-/

example (a : ℝ) : a = a := by
  rfl

/-
在这个例子中, 我们用了一个新的标识符 `example` 而不是 `theorem`. `example` 这个标识符也可用于引导一个定理, 其与 `theorem` 的区别在于, 使用 `example` 引导的定理 **不需要** 起名字, 但同样地, 这样写出来的定理也无法被复用. 其往往用于课程讲授时的例子展示, 属于使用后即抛弃的代码.

回到定理本身, 这个定理叙述的是, "对于一个实数 `a`, 等式 `a = a` 成立". 或许一开始你会有点疑惑, `a = a` 这件事情难道还需要证明吗? 遗憾的是, 在 Lean 中这确实是一件需要证明的事情. 但正如每个人一开始的想法, `a` 和 `a` 本身就是一模一样的东西, 它们本该相等; 或者用更严谨的数学语言来说, `=` 是一个等价关系, 应满足自反性, 因此 `a = a` 是成立的.

这样一件简单的事情在 Lean 中当然也可以被简单地实现. 自反策略 `rfl` 就是用于证明形如 `a = a` 这样的等式. 具体来讲, 就像上面例子展示的那样, 当目标是 `a = a` 时, `rfl` 会帮助我们结束证明.

有些令人感到疑惑的地方是, 在最开始介绍 `rw` 的时候, 改写过程的最后一步往往会将等号两边改写成一模一样的表达式, 这时候为什么 Lean 提示我们证明结束, 而没有让我们证明形如 `a = a` 这样的等式呢? 实际上, `rw` 相等于内置了一个 `rfl`. 每当 `rw` 完成一次改写后, 它都会尝试一次 `rfl`. 如果当前的目标恰好是 `a = a` 这样的形式, 那么 `rfl` 就可以结束证明; 如果当前的目标不是 `a = a` 这样的形式, 那么 `rfl` 无效, `rw` 就会把改写后的新目标呈现出来, 等待我们的下一步操作.
-/


/-
# 随堂练习

请利用所给定理, 通过改写策略完成证明.
-/

#check mul_assoc
#check mul_comm
example (a b c : ℕ) : a * b * c = b * (a * c) := by
  sorry


#check sub_self
example (a b c d : ℝ) (hyp : c = b * a - d) (hyp' : d = a * b) : c = 0 := by
  sorry

#check add_zero
#check neg_add_cancel_left
example {a b : ℝ} (h : a + b = 0) : -a = b := by
  sorry
